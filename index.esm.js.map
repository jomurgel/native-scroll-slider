{"version":3,"file":"index.esm.js","sources":["../src/index.js"],"sourcesContent":["/**\n * NativeScrollSlider\n *\n * A simple slider that leverages native overflow scroll behavior.\n *\n * @author Jo Murgel\n * @version 0.0.2\n * @license MIT\n * @copyright 2024 Jo Murgel\n * @see https://github.com/jomurgel/native-scroll-slider\n * @see https://www.npmjs.com/package/@jomurgel/native-scroll-slider\n */\nclass NativeScrollSlider {\n\n  /**\n     * Initialize the slider.\n     *\n     * @constructor\n     * @param {HTMLElement} trackElement - The track element containing the slides.\n     * @param {Object} options - The options for the slider.\n     * @returns {void}\n     */\n  constructor(trackElement, options = {}) {\n    // Safety checks\n    if (!trackElement) {\n      console.error('NativeScrollSlider: trackElement is null or undefined');\n      return;\n    }\n\n    this.track = trackElement;\n\n    // Find container - look up the DOM tree for a container with data-slider-config or use parent\n    this.container = this.findContainer(trackElement);\n\n    // Merge options: defaults < data-slider-config < passed options\n    this.options = this.buildConfig(options);\n\n    // Find slides within the track\n    this.slides = Array.from(this.track.children);\n\n    if (this.slides.length === 0) {\n      console.error('NativeScrollSlider: no slides found in track', this.track);\n      return;\n    }\n\n    // Find navigation buttons\n    this.prevBtn = this.findNavButton(this.options.prevElement);\n    this.nextBtn = this.findNavButton(this.options.nextElement);\n\n    this.currentSlide = 0;\n    this.totalSlides = this.slides.length;\n    this.autoplayInterval = null;\n    this.slidePositions = [];\n    this.isScrolling = false;\n    this.scrollTimeout = null;\n\n    this.init();\n  }\n\n  /**\n     * Find the container element by looking up the DOM tree\n     *\n     * @param {HTMLElement} trackElement\n     * @returns {HTMLElement}\n     */\n  findContainer(trackElement) {\n    let element = trackElement;\n\n    // Look up the DOM tree for an element with data-slider-config\n    while (element && element !== document.body) {\n      if (element.dataset.sliderConfig) {\n        return element;\n      }\n      element = element.parentElement;\n    }\n\n    // If no container with config found, use track's parent or track itself\n    return trackElement.parentElement || trackElement;\n  }\n\n  /**\n     * Build the configuration by merging defaults, data attributes, and passed options\n     *\n     * @param {Object} passedOptions\n     * @returns {Object}\n     */\n  buildConfig(passedOptions) {\n    // Default configuration\n    const defaults = {\n      slidesToShow: 4,\n      slidesToScroll: 1,\n      infinite: false,\n      bounceBack: false,\n      centerMode: false,\n      autoplay: false,\n      autoplaySpeed: 3000,\n      gap: 24,\n      startSlide: 0,\n      // @see https://dev.to/gerryleonugroho/responsive-design-breakpoints-2025-playbook-53ih\n      responsive: [\n        {\n          breakpoint: 1200,\n          settings: {\n            slidesToShow: 3\n          }\n        },\n        {\n          breakpoint: 992,\n          settings: {\n            slidesToShow: 2\n          }\n        },\n        {\n          breakpoint: 768,\n          settings: {\n            slidesToShow: 1\n          }\n        },\n        {\n          breakpoint: 576,\n          settings: {\n            slidesToShow: 1\n          }\n        }\n      ],\n      prevElement: '.prev, .slider-prev, .slider-grid-prev',\n      nextElement: '.next, .slider-next, .slider-grid-next',\n      minSlideWidth: 0,\n      showOverflow: false,\n      overflowAmount: 0.5,\n      containerMaxWidth: 1200,\n      basePadding: 35\n    };\n\n    // Try to get config from data attribute\n    let dataConfig = {};\n    if (this.container && this.container.dataset.sliderConfig) {\n      try {\n        dataConfig = JSON.parse(this.container.dataset.sliderConfig);\n      } catch (e) {\n        console.warn('NativeScrollSlider: Invalid JSON in data-slider-config', e);\n      }\n    }\n\n    // Merge: defaults < dataConfig < passedOptions\n    return Object.assign({}, defaults, dataConfig, passedOptions);\n  }\n\n  /**\n     * Find navigation button using querySelector\n     *\n     * @param {string} selector\n     * @returns {HTMLElement|null}\n     */\n  findNavButton(selector) {\n    if (!selector) return null;\n\n    // First try within container\n    let button = this.container.querySelector(selector);\n\n    // If not found, try within track\n    if (!button) {\n      button = this.track.querySelector(selector);\n    }\n\n    // If still not found, look for sibling .slider-controls container\n    if (!button && this.container.parentElement) {\n      const sliderControls = this.container.parentElement.querySelector('.slider-controls');\n      if (sliderControls) {\n        // Look for the specific prev/next button within slider-controls\n        if (selector.includes('prev')) {\n          button = sliderControls.querySelector('.slider-prev');\n        } else if (selector.includes('next')) {\n          button = sliderControls.querySelector('.slider-next');\n        }\n      }\n    }\n\n    return button;\n  }\n\n  /**\n     * Initialize the slider.\n     *\n     * @returns {void}\n     */\n  init() {\n    // Setup responsive settings FIRST\n    this.setupResponsive();\n\n    // Now we can setup track styles with correct currentOptions\n    this.setupTrackStyles();\n\n    this.setupSlides();\n    this.calculateSlidePositions();\n    this.setupNavigation();\n    this.setupScrollListener();\n    this.setupAutoplay();\n\n    const self = this;\n    window.addEventListener('resize', () => {\n      self.handleResize();\n    });\n\n    this.container.classList.add('slider-ready');\n\n    setTimeout(() => {\n      self.goToSlide(self.currentOptions.startSlide);\n    }, 50);\n\n    this.updateCurrentSlideFromScroll();\n  }\n\n  /**\n     * Setup basic track styles for horizontal scrolling\n     *\n     * @returns {void}\n     */\n  setupTrackStyles() {\n    this.track.style.display = 'flex';\n    this.track.style.overflowX = 'auto';\n    this.track.style.scrollBehavior = 'smooth';\n    this.track.style.scrollbarWidth = 'none';\n    this.track.style.msOverflowStyle = 'none';\n\n    // Setup or reset pull-to-right styles based on current options\n    if (this.currentOptions.showOverflow) {\n      this.setupPullToRightStyles();\n    } else {\n      this.resetPullToRightStyles();\n    }\n\n    // Hide webkit scrollbars\n    if (!document.getElementById('native-scroll-slider-styles')) {\n      const style = document.createElement('style');\n      style.id = 'native-scroll-slider-styles';\n      style.textContent = `\n\t\t\t\t\t\t  .slider-ready .slider-track::-webkit-scrollbar,\n\t\t\t\t\t\t  [data-slider-config] > *::-webkit-scrollbar {\n\t\t\t\t\t\t\t  display: none;\n\t\t\t\t\t\t  }\n\t\t\t\t\t  `;\n      document.head.appendChild(style);\n    }\n  }\n\n  /**\n     * Setup pull-to-right styles to break out to viewport width\n     *\n     * @returns {void}\n     */\n  setupPullToRightStyles() {\n    // Break container out to full viewport width\n    this.container.style.width = '100vw';\n    this.container.style.position = 'relative';\n    this.container.style.left = '50%';\n    this.container.style.right = '50%';\n    this.container.style.marginLeft = '-50vw';\n    this.container.style.marginRight = '-50vw';\n\n    // Calculate left padding to maintain alignment with page content\n    this.updatePullToRightPadding();\n  }\n\n  /**\n     * Reset pull-to-right styles when disabled\n     *\n     * @returns {void}\n     */\n  resetPullToRightStyles() {\n    // Reset container styles\n    this.container.style.width = '';\n    this.container.style.position = '';\n    this.container.style.left = '';\n    this.container.style.right = '';\n    this.container.style.marginLeft = '';\n    this.container.style.marginRight = '';\n\n    // Reset track padding - it will be recalculated in setupSlides\n    this.track.style.paddingLeft = '';\n    this.track.style.paddingRight = '';\n\n    // Clear stored padding\n    this.pullToRightLeftPadding = 0;\n  }\n\n  /**\n     * Update pull-to-right padding based on viewport and container size\n     *\n     * @returns {void}\n     */\n  updatePullToRightPadding() {\n    if (!this.currentOptions.showOverflow) {\n      return;\n    }\n\n    const viewportWidth = window.innerWidth;\n    const containerMaxWidth = this.currentOptions.containerMaxWidth; // Use currentOptions\n    const basePadding = this.currentOptions.basePadding; // Use currentOptions\n\n    let leftPadding;\n\n    if (viewportWidth <= containerMaxWidth + (basePadding * 2)) {\n      // On smaller screens, just use base padding\n      leftPadding = basePadding;\n    } else {\n      // On larger screens, calculate padding to align with page content\n      leftPadding = Math.max(basePadding, (viewportWidth - containerMaxWidth) / 2 + basePadding);\n    }\n\n    // Apply the calculated padding\n    this.track.style.paddingLeft = leftPadding + 'px';\n    this.track.style.paddingRight = basePadding + 'px';\n\n    // Store the calculated padding for use in slide calculations\n    this.pullToRightLeftPadding = leftPadding;\n  }\n\n  /**\n   * Setup the responsive settings.\n   *\n   * @returns {void}\n   */\n  setupResponsive() {\n    const width = window.innerWidth;\n    let currentOptions = Object.assign({}, this.options);\n\n    // Sort responsive breakpoints in descending order (largest first)\n    const sortedBreakpoints = [...this.options.responsive].sort((a, b) => b.breakpoint - a.breakpoint);\n\n    // Apply settings from all matching breakpoints in cascade (largest to smallest)\n    for (let i = 0; i < sortedBreakpoints.length; i++) {\n      const breakpoint = sortedBreakpoints[i];\n      if (width <= breakpoint.breakpoint) {\n        // Apply this breakpoint's settings on top of previous settings\n        currentOptions = Object.assign(currentOptions, breakpoint.settings);\n        // Don't break - continue to apply smaller breakpoints too\n      }\n    }\n\n    this.currentOptions = currentOptions;\n  }\n\n  /**\n   * Setup the slides.\n   *\n   * @returns {void}\n   */\n  setupSlides() {\n    if (!this.track) {\n      console.error('setupSlides: track is null');\n      return;\n    }\n\n    this.track.style.gap = this.currentOptions.gap + 'px';\n\n    if (!this.container) {\n      console.error('setupSlides: container is null');\n      return;\n    }\n\n    let containerWidth = this.container.offsetWidth;\n    let leftPadding, totalGaps, slideWidth, overflowSlideWidth, totalNeededWidth;\n\n    // Handle pull-to-right mode\n    if (this.currentOptions.showOverflow) {\n      // Update padding first\n      this.updatePullToRightPadding();\n\n      // Use viewport width for calculations since container is now 100vw\n      containerWidth = window.innerWidth;\n\n      // Account for the left padding we applied\n      const effectiveWidth = containerWidth - this.pullToRightLeftPadding - this.currentOptions.basePadding;\n\n      totalGaps = (this.currentOptions.slidesToShow - 1) * this.currentOptions.gap;\n      overflowSlideWidth = 0;\n\n      if (this.currentOptions.overflowAmount > 0) {\n        const tempSlideWidth = (effectiveWidth - totalGaps - this.currentOptions.gap) / (this.currentOptions.slidesToShow + this.currentOptions.overflowAmount);\n        overflowSlideWidth = tempSlideWidth * this.currentOptions.overflowAmount;\n      }\n\n      let calculatedSlideWidth = (effectiveWidth - totalGaps - overflowSlideWidth) / this.currentOptions.slidesToShow;\n\n      // Apply minSlideWidth if defined - force it regardless of slidesToShow\n      const minSlideWidth = this.parseMinSlideWidth();\n      if (minSlideWidth > 0 && calculatedSlideWidth < minSlideWidth) {\n        slideWidth = minSlideWidth;\n\n        // Calculate how many slides can actually fit at this minimum width\n        // For overflow mode, we need to account for the overflow space too\n        // const availableForSlides = effectiveWidth - overflowSlideWidth;\n        // const maxSlidesAtMinWidth = Math.floor((availableForSlides + this.currentOptions.gap) / (minSlideWidth + this.currentOptions.gap));\n        // const actualSlidesToShow = Math.max(1, Math.min(maxSlidesAtMinWidth, this.currentOptions.slidesToShow));\n      } else {\n        slideWidth = calculatedSlideWidth;\n      }\n\n      // Don't add additional padding - we already set it in updatePullToRightPadding\n      leftPadding = 0;\n    } else {\n      // Regular mode\n      totalGaps = (this.currentOptions.slidesToShow - 1) * this.currentOptions.gap;\n      let calculatedSlideWidth = (containerWidth - totalGaps) / this.currentOptions.slidesToShow;\n\n      // Apply minSlideWidth constraint - force the width but don't change slide count\n      const minSlideWidth = this.parseMinSlideWidth();\n      if (minSlideWidth > 0 && calculatedSlideWidth < minSlideWidth) {\n        slideWidth = minSlideWidth;\n\n        // Keep original slidesToShow but recalculate total needed width\n        totalNeededWidth = (slideWidth * this.currentOptions.slidesToShow) + totalGaps;\n\n        if (this.currentOptions.centerMode) {\n          // For center mode, center the content within container\n          leftPadding = Math.max(0, (containerWidth - totalNeededWidth) / 2);\n        } else {\n          // For non-center mode, allow overflow - align left with minimal padding\n          leftPadding = Math.max(0, (containerWidth - totalNeededWidth) / 2);\n        }\n      } else {\n        // No minWidth constraint or already meets it\n        slideWidth = calculatedSlideWidth;\n        totalNeededWidth = (slideWidth * this.currentOptions.slidesToShow) + totalGaps;\n        leftPadding = Math.max(0, (containerWidth - totalNeededWidth) / 2);\n      }\n\n      // Apply padding to track\n      this.track.style.paddingLeft = leftPadding + 'px';\n      this.track.style.paddingRight = leftPadding + 'px';\n    }\n\n    // Apply slide widths\n    for (let i = 0; i < this.slides.length; i++) {\n      if (this.slides[i] && this.slides[i].style) {\n        this.slides[i].style.width = slideWidth + 'px';\n        this.slides[i].style.flexShrink = '0';\n      }\n    }\n\n    if ((this.currentOptions.infinite || this.currentOptions.bounceBack) && this.totalSlides > this.currentOptions.slidesToShow) {\n      if (this.currentOptions.infinite) {\n        this.setupTrueInfinite();\n      } else if (this.currentOptions.bounceBack) {\n        this.setupBounceBack();\n      }\n    }\n  }\n\n  /**\n   * Parse minSlideWidth from string or number\n   *\n   * @returns {number}\n   */\n  parseMinSlideWidth() {\n    if (!this.currentOptions.minSlideWidth) return 0;\n\n    const minWidth = this.currentOptions.minSlideWidth;\n    if (typeof minWidth === 'string') {\n      // Handle \"0px\", \"100px\", etc.\n      const numericValue = parseFloat(minWidth);\n      return isNaN(numericValue) ? 0 : numericValue;\n    }\n\n    return typeof minWidth === 'number' ? minWidth : 0;\n  }\n\n  /**\n   * Setup bounce back or infinite mode\n   *\n   * @param {string} mode - 'bounce' or 'infinite'\n   * @returns {void}\n   */\n  setupClonedSlides(mode) {\n    const slidesToClone = mode === 'infinite'\n      ? this.currentOptions.slidesToShow + 1\n      : Math.max(this.currentOptions.slidesToShow, 2);\n\n    if (mode === 'infinite') {\n      // Clone slides to end\n      for (let i = 0; i < slidesToClone; i++) {\n        const originalIndex = i % this.totalSlides;\n        const clone = this.slides[originalIndex].cloneNode(true);\n        clone.classList.add('cloned', 'infinite-clone');\n        clone.dataset.originalIndex = originalIndex;\n        this.track.appendChild(clone);\n      }\n\n      // Clone slides to beginning\n      for (let i = 0; i < slidesToClone; i++) {\n        const originalIndex = (this.totalSlides - slidesToClone + i) % this.totalSlides;\n        const clone = this.slides[originalIndex].cloneNode(true);\n        clone.classList.add('cloned', 'infinite-clone');\n        clone.dataset.originalIndex = originalIndex;\n        this.track.insertBefore(clone, this.track.firstChild);\n      }\n\n      this.initialCloneCount = slidesToClone;\n    } else {\n      // Bounce mode: clone to end\n      for (let i = 0; i < slidesToClone; i++) {\n        const clone = this.slides[i].cloneNode(true);\n        clone.classList.add('cloned', 'bounce-clone');\n        this.track.appendChild(clone);\n      }\n\n      // Clone to beginning\n      for (let i = this.totalSlides - slidesToClone; i < this.totalSlides; i++) {\n        const clone = this.slides[i].cloneNode(true);\n        clone.classList.add('cloned', 'bounce-clone');\n        this.track.insertBefore(clone, this.track.firstChild);\n      }\n    }\n\n    this.allSlides = Array.from(this.track.children);\n\n    // Set initial position after DOM updates\n    const self = this;\n    setTimeout(() => {\n      self.calculateSlidePositions();\n\n      const startIndex = mode === 'infinite'\n        ? slidesToClone + self.currentOptions.startSlide\n        : slidesToClone + self.currentOptions.startSlide;\n\n      let initialPosition = self.slidePositions[startIndex];\n\n      // Apply centerMode calculations if needed\n      if (self.currentOptions.centerMode) {\n        const trackStyles = window.getComputedStyle(self.track);\n        const trackPaddingLeft = parseFloat(trackStyles.paddingLeft) || 0;\n        const trackPaddingRight = parseFloat(trackStyles.paddingRight) || 0;\n        const visibleTrackWidth = self.track.offsetWidth - trackPaddingLeft - trackPaddingRight;\n\n        const slideWidth = self.slides[0].offsetWidth;\n        initialPosition = initialPosition - (visibleTrackWidth / 2) + (slideWidth / 2);\n      }\n\n      self.track.scrollLeft = initialPosition;\n      self.currentSlide = self.currentOptions.startSlide;\n    }, 10);\n  }\n\n  /**\n   * Setup the bounce back.\n   *\n   * @returns {void}\n   */\n  setupBounceBack() {\n    this.setupClonedSlides('bounce');\n  }\n\n  /**\n   * Setup the true infinite scroll with a simpler, more reliable approach\n   *\n   * @returns {void}\n   */\n  setupTrueInfinite() {\n    // Calculate how many clones we need for smooth infinite scrolling\n    // We need enough clones on each side to handle the maximum scroll distance\n    const containerWidth = this.container.offsetWidth;\n    const slideWidth = this.slides[0].offsetWidth + this.currentOptions.gap;\n    const slidesPerView = Math.ceil(containerWidth / slideWidth);\n\n    // Create enough clones to fill at least 2 viewport widths on each side\n    const clonesNeeded = Math.max(this.totalSlides, slidesPerView * 2);\n\n    this.initialCloneCount = clonesNeeded;\n\n    // Clone slides to the end\n    for (let i = 0; i < clonesNeeded; i++) {\n      const originalIndex = i % this.totalSlides;\n      const clone = this.slides[originalIndex].cloneNode(true);\n      clone.classList.add('cloned', 'infinite-clone');\n      clone.dataset.originalIndex = originalIndex;\n      this.track.appendChild(clone);\n    }\n\n    // Clone slides to the beginning\n    for (let i = 0; i < clonesNeeded; i++) {\n      const originalIndex = (this.totalSlides - 1 - (i % this.totalSlides)) % this.totalSlides;\n      const clone = this.slides[originalIndex].cloneNode(true);\n      clone.classList.add('cloned', 'infinite-clone');\n      clone.dataset.originalIndex = originalIndex;\n      this.track.insertBefore(clone, this.track.firstChild);\n    }\n\n    this.allSlides = Array.from(this.track.children);\n\n    // Set initial position after DOM updates\n    const self = this;\n    setTimeout(() => {\n      self.calculateSlidePositions();\n\n      // Start in the middle section (original slides)\n      const startIndex = clonesNeeded + self.currentOptions.startSlide;\n      let initialPosition = self.slidePositions[startIndex];\n\n      // Apply centerMode calculations if needed\n      if (self.currentOptions.centerMode) {\n        const trackStyles = window.getComputedStyle(self.track);\n        const trackPaddingLeft = parseFloat(trackStyles.paddingLeft) || 0;\n        const trackPaddingRight = parseFloat(trackStyles.paddingRight) || 0;\n        const visibleTrackWidth = self.track.offsetWidth - trackPaddingLeft - trackPaddingRight;\n        const slideWidth = self.slides[0].offsetWidth;\n        initialPosition = initialPosition - (visibleTrackWidth / 2) + (slideWidth / 2);\n      }\n\n      // Disable smooth scrolling temporarily for initial positioning\n      self.track.style.scrollBehavior = 'auto';\n      self.track.scrollLeft = initialPosition;\n      self.track.style.scrollBehavior = 'smooth';\n\n      self.currentSlide = self.currentOptions.startSlide;\n      self.infiniteScrollSetup = true;\n    }, 10);\n  }\n\n  /**\n     * Calculate the slide positions.\n     *\n     * @returns {void}\n     */\n  calculateSlidePositions() {\n    this.slidePositions = [];\n    const slidesToUse = this.allSlides || this.slides;\n    const leftPadding = parseFloat(this.track.style.paddingLeft) || 0;\n\n    for (let i = 0; i < slidesToUse.length; i++) {\n      this.slidePositions.push(slidesToUse[i].offsetLeft - leftPadding);\n    }\n  }\n\n  /**\n   * Enhanced scroll listener for infinite scroll\n   *\n   * @returns {void}\n   */\n  setupScrollListener() {\n    const self = this;\n\n    this.track.addEventListener('scroll', () => {\n      self.isScrolling = true;\n      self.pauseAutoplay();\n\n      // Handle infinite scroll with debouncing\n      if (self.currentOptions.infinite) {\n        clearTimeout(self.infiniteScrollTimeout);\n        self.infiniteScrollTimeout = setTimeout(() => {\n          self.handleInfiniteScroll();\n        }, 50); // Quick response for seamless experience\n      }\n\n      clearTimeout(self.scrollTimeout);\n      self.scrollTimeout = setTimeout(() => {\n        self.isScrolling = false;\n        self.resumeAutoplay();\n      }, 150);\n\n      self.updateCurrentSlideFromScroll();\n    }, { passive: true });\n  }\n\n  /**\n   * Update the current slide from the scroll.\n   *\n   * @returns {void}\n   */\n  updateCurrentSlideFromScroll() {\n    const scrollLeft = this.track.scrollLeft;\n\n    // For infinite mode, don't track slides - just let it scroll freely.\n    if (this.currentOptions.infinite) {\n      this.updateCenterMode();\n      return;\n    }\n\n    let adjustedScrollLeft = scrollLeft;\n    if (this.currentOptions.centerMode) {\n      // Get actual container dimensions accounting for padding\n      const containerStyles = window.getComputedStyle(this.container);\n      const containerPaddingLeft = parseFloat(containerStyles.paddingLeft) || 0;\n      const containerPaddingRight = parseFloat(containerStyles.paddingRight) || 0;\n      const containerInnerWidth = this.container.offsetWidth - containerPaddingLeft - containerPaddingRight;\n\n      // Adjust scroll position to account for centering and container padding\n      adjustedScrollLeft = scrollLeft + (containerInnerWidth / 2) + containerPaddingLeft;\n    }\n\n    let closestSlide = 0;\n    let closestDistance = Infinity;\n\n    for (let i = 0; i < this.slidePositions.length; i++) {\n      const position = this.slidePositions[i];\n      let comparePosition = position;\n      if (this.currentOptions.centerMode) {\n        const slideWidth = this.slides[0].offsetWidth;\n        comparePosition = position + (slideWidth / 2);\n      }\n\n      const distance = Math.abs(adjustedScrollLeft - comparePosition);\n      if (distance < closestDistance) {\n        closestDistance = distance;\n        closestSlide = i;\n      }\n    }\n\n    if (this.currentOptions.bounceBack && this.allSlides) {\n      const cloneCount = Math.max(this.currentOptions.slidesToShow, 2);\n      if (closestSlide >= cloneCount && closestSlide < cloneCount + this.totalSlides) {\n        this.currentSlide = closestSlide - cloneCount;\n      }\n    } else {\n      this.currentSlide = closestSlide;\n    }\n\n    this.updateNavigation();\n    this.updateCenterMode();\n  }\n\n  /**\n     * Handle the scroll end.\n     *\n     * @returns {void}\n     */\n  handleScrollEnd() {\n    if (this.currentOptions.bounceBack) {\n      this.handleBounceBackScroll();\n    } else if (this.currentOptions.infinite) {\n      this.handleInfiniteScroll();\n    }\n  }\n\n  /**\n     * Handle the bounce back scroll.\n     *\n     * @returns {void}\n     */\n  handleBounceBackScroll() {\n    const cloneCount = Math.max(this.currentOptions.slidesToShow, 2);\n    const scrollLeft = this.track.scrollLeft;\n    const slideWidth = this.slides[0].offsetWidth + this.currentOptions.gap;\n\n    if (scrollLeft < cloneCount * slideWidth / 2) {\n      const targetIndex = cloneCount + this.totalSlides - (cloneCount - Math.floor(scrollLeft / slideWidth));\n      this.track.scrollLeft = this.slidePositions[targetIndex];\n    } else if (scrollLeft > this.slidePositions[cloneCount + this.totalSlides - 1]) {\n      const targetIndex = cloneCount + (this.currentSlide % this.totalSlides);\n      this.track.scrollLeft = this.slidePositions[targetIndex];\n    }\n  }\n\n  /**\n   * Handle infinite scroll with seamless looping\n   *\n   * @returns {void}\n   */\n  handleInfiniteScroll() {\n    if (!this.infiniteScrollSetup) return;\n\n    const scrollLeft = this.track.scrollLeft;\n    const slideWidth = this.slides[0].offsetWidth + this.currentOptions.gap;\n    const totalOriginalWidth = this.totalSlides * slideWidth;\n\n    // Calculate the boundaries where we need to \"teleport\"\n    const leftBoundary = slideWidth * 2; // 2 slides worth of buffer\n    const rightBoundary = this.slidePositions[this.initialCloneCount + this.totalSlides] - slideWidth * 2;\n\n    // If we've scrolled too far left, jump to the equivalent position on the right\n    if (scrollLeft <= leftBoundary) {\n      const equivalentPosition = scrollLeft + totalOriginalWidth;\n      this.seamlessJump(equivalentPosition);\n    }\n    // If we've scrolled too far right, jump to the equivalent position on the left\n    else if (scrollLeft >= rightBoundary) {\n      const equivalentPosition = scrollLeft - totalOriginalWidth;\n      this.seamlessJump(equivalentPosition);\n    }\n  }\n\n  /**\n     * Setup the navigation.\n     *\n     * @returns {void}\n     */\n  setupNavigation() {\n    const self = this;\n    if (this.prevBtn) {\n      this.prevBtn.addEventListener('click', () => {\n        self.prev();\n      });\n    }\n\n    if (this.nextBtn) {\n      this.nextBtn.addEventListener('click', () => {\n        self.next();\n      });\n    }\n\n    this.updateNavigation();\n  }\n\n  /**\n   * Go to the slide.\n   *\n   * @param {number} slideIndex - The index of the slide to go to.\n   * @returns {void}\n   */\n  goToSlide(slideIndex) {\n    // For infinite mode, don't use goToSlide - just use next/prev buttons.\n    if (this.currentOptions.infinite) {\n      return;\n    }\n\n    if (slideIndex < 0 || slideIndex >= this.totalSlides) return;\n\n    let targetPosition;\n\n    if (this.currentOptions.bounceBack) {\n      const cloneCount = Math.max(this.currentOptions.slidesToShow, 2);\n      targetPosition = this.slidePositions[cloneCount + slideIndex];\n    } else {\n      targetPosition = this.slidePositions[slideIndex];\n    }\n\n    if (this.currentOptions.centerMode) {\n      // Get actual container dimensions accounting for padding\n      const containerStyles = window.getComputedStyle(this.container);\n      const containerPaddingLeft = parseFloat(containerStyles.paddingLeft) || 0;\n      const containerPaddingRight = parseFloat(containerStyles.paddingRight) || 0;\n      const containerInnerWidth = this.container.offsetWidth - containerPaddingLeft - containerPaddingRight;\n\n      const slideWidth = this.slides[0].offsetWidth;\n\n      // Center the slide within the container's inner width\n      targetPosition = targetPosition - (containerInnerWidth / 2) + (slideWidth / 2);\n\n      // Account for container padding offset in scroll position\n      targetPosition = targetPosition - containerPaddingLeft;\n    }\n\n    this.track.scrollTo({\n      left: targetPosition,\n      behavior: 'smooth'\n    });\n\n    this.currentSlide = slideIndex;\n  }\n\n  /**\n   * Perform a seamless jump to maintain infinite scroll illusion\n   *\n   * @param {number} newPosition - The new scroll position\n   * @returns {void}\n   */\n  seamlessJump(newPosition) {\n    // Temporarily disable smooth scrolling for the jump\n    const originalBehavior = this.track.style.scrollBehavior;\n    this.track.style.scrollBehavior = 'auto';\n\n    // Perform the jump\n    this.track.scrollLeft = newPosition;\n\n    // Re-enable smooth scrolling after a small delay\n    setTimeout(() => {\n      this.track.style.scrollBehavior = originalBehavior || 'smooth';\n    }, 10);\n  }\n\n  /**\n   * Calculate how many slides are actually visible in the current viewport\n   * @returns {number}\n   */\n  getActualSlidesToShow() {\n    if (!this.slides.length) return this.currentOptions.slidesToShow;\n\n    const containerWidth = this.container.offsetWidth;\n    const slideWidth = this.slides[0].offsetWidth;\n    const gap = this.currentOptions.gap;\n\n    // Calculate how many slides actually fit in the visible area\n    const actualSlidesToShow = Math.floor((containerWidth + gap) / (slideWidth + gap));\n\n    // Return the smaller of configured vs actual\n    return Math.min(actualSlidesToShow, this.currentOptions.slidesToShow);\n  }\n\n  /**\n   * Enhanced next method for infinite scroll\n   *\n   * @returns {void}\n   */\n  next() {\n    // For infinite mode, just scroll by the specified amount\n    if (this.currentOptions.infinite) {\n      const slideWidth = this.slides[0].offsetWidth + this.currentOptions.gap;\n      const scrollAmount = slideWidth * this.currentOptions.slidesToScroll;\n\n      if (this.currentOptions.centerMode) {\n        // For center mode, we need to find the current center slide and go to the next one\n        const currentCenterSlide = this.findCurrentCenterSlideIndex();\n        const nextCenterSlide = currentCenterSlide + this.currentOptions.slidesToScroll;\n        this.goToCenterSlide(nextCenterSlide);\n      } else {\n        this.track.scrollTo({\n          left: this.track.scrollLeft + scrollAmount,\n          behavior: 'smooth'\n        });\n      }\n      return;\n    }\n\n    const actualSlidesToShow = this.getActualSlidesToShow();\n\n    // Non-infinite mode logic remains the same\n    let nextSlide;\n    if (this.currentOptions.bounceBack) {\n      nextSlide = (this.currentSlide + this.currentOptions.slidesToScroll) % this.totalSlides;\n    } else {\n      // Use actualSlidesToShow instead of this.currentOptions.slidesToShow\n      nextSlide = Math.min(\n        this.currentSlide + this.currentOptions.slidesToScroll,\n        this.totalSlides - actualSlidesToShow\n      );\n    }\n\n    this.goToSlide(nextSlide);\n  }\n\n  /**\n   * Enhanced prev method for infinite scroll\n   *\n   * @returns {void}\n   */\n  prev() {\n    // For infinite mode, just scroll by the specified amount\n    if (this.currentOptions.infinite) {\n      const slideWidth = this.slides[0].offsetWidth + this.currentOptions.gap;\n      const scrollAmount = slideWidth * this.currentOptions.slidesToScroll;\n\n      if (this.currentOptions.centerMode) {\n        // For center mode, we need to find the current center slide and go to the previous one\n        const currentCenterSlide = this.findCurrentCenterSlideIndex();\n        const prevCenterSlide = currentCenterSlide - this.currentOptions.slidesToScroll;\n        this.goToCenterSlide(prevCenterSlide);\n      } else {\n        this.track.scrollTo({\n          left: this.track.scrollLeft - scrollAmount,\n          behavior: 'smooth'\n        });\n      }\n      return;\n    }\n\n    // Non-infinite mode logic remains the same\n    let prevSlide;\n    if (this.currentOptions.bounceBack) {\n      prevSlide = this.currentSlide - this.currentOptions.slidesToScroll;\n      if (prevSlide < 0) {\n        prevSlide = this.totalSlides + prevSlide;\n      }\n    } else {\n      prevSlide = Math.max(this.currentSlide - this.currentOptions.slidesToScroll, 0);\n    }\n\n    this.goToSlide(prevSlide);\n  }\n\n  /**\n   * Find the index of the currently centered slide in infinite mode\n   *\n   * @returns {number}\n   */\n  findCurrentCenterSlideIndex() {\n    const scrollLeft = this.track.scrollLeft;\n    const trackStyles = window.getComputedStyle(this.track);\n    const trackPaddingLeft = parseFloat(trackStyles.paddingLeft) || 0;\n    const visibleTrackWidth = this.track.offsetWidth - trackPaddingLeft - (parseFloat(trackStyles.paddingRight) || 0);\n\n    // Find the center point of the visible area\n    const centerPoint = scrollLeft + (visibleTrackWidth / 2);\n\n    let closestSlide = 0;\n    let closestDistance = Infinity;\n\n    const slidesToUse = this.allSlides || this.slides;\n    for (let i = 0; i < slidesToUse.length; i++) {\n      const slide = slidesToUse[i];\n      const slideCenter = slide.offsetLeft + (slide.offsetWidth / 2) - trackPaddingLeft;\n      const distance = Math.abs(centerPoint - slideCenter);\n\n      if (distance < closestDistance) {\n        closestDistance = distance;\n        closestSlide = i;\n      }\n    }\n\n    return closestSlide;\n  }\n\n  /**\n   * Go to a specific slide index and center it (for infinite mode)\n   *\n   * @param {number} slideIndex\n   * @returns {void}\n   */\n  goToCenterSlide(slideIndex) {\n    const slidesToUse = this.allSlides || this.slides;\n\n    // Make sure index is within bounds\n    if (slideIndex < 0 || slideIndex >= slidesToUse.length) {\n      return;\n    }\n\n    const targetSlide = slidesToUse[slideIndex];\n    const trackStyles = window.getComputedStyle(this.track);\n    const trackPaddingLeft = parseFloat(trackStyles.paddingLeft) || 0;\n    const trackPaddingRight = parseFloat(trackStyles.paddingRight) || 0;\n    const visibleTrackWidth = this.track.offsetWidth - trackPaddingLeft - trackPaddingRight;\n\n    // Calculate position to center this slide\n    const slideLeft = targetSlide.offsetLeft - trackPaddingLeft;\n    const slideWidth = targetSlide.offsetWidth;\n    const targetPosition = slideLeft - (visibleTrackWidth / 2) + (slideWidth / 2);\n\n    this.track.scrollTo({\n      left: targetPosition,\n      behavior: 'smooth'\n    });\n  }\n\n  /**\n     * Update the navigation.\n     *\n     * @returns {void}\n     */\n  updateNavigation() {\n    if (!this.prevBtn || !this.nextBtn) return;\n\n    // For infinite mode, buttons are always enabled\n    if (this.currentOptions.infinite) {\n      this.prevBtn.disabled = false;\n      this.nextBtn.disabled = false;\n      return;\n    }\n\n    if (this.currentOptions.bounceBack) {\n      this.prevBtn.disabled = false;\n      this.nextBtn.disabled = false;\n    } else {\n      this.prevBtn.disabled = this.currentSlide === 0;\n\n      // Calculate the actual last scrollable position\n      const maxScroll = this.track.scrollWidth - this.track.clientWidth;\n      const currentScroll = this.track.scrollLeft;\n\n      // Disable next if we can't scroll further right\n      // Add a small buffer (5px) to account for rounding errors\n      this.nextBtn.disabled = currentScroll >= maxScroll - 5;\n    }\n  }\n\n  /**\n     * Update the center mode.\n     *\n     * @returns {void}\n     */\n  updateCenterMode() {\n    if (!this.currentOptions.centerMode) return;\n\n    const slidesToUse = this.allSlides || this.slides;\n    for (let i = 0; i < slidesToUse.length; i++) {\n      slidesToUse[i].classList.remove('center');\n    }\n\n    let centerSlideIndex;\n    if (this.currentOptions.bounceBack) {\n      const cloneCount = Math.max(this.currentOptions.slidesToShow, 2);\n      centerSlideIndex = cloneCount + this.currentSlide;\n    } else if (this.currentOptions.infinite) {\n      const scrollLeft = this.track.scrollLeft;\n      const containerWidth = this.container.offsetWidth;\n      const centerPoint = scrollLeft + (containerWidth / 2);\n\n      let closestSlide = null;\n      let closestDistance = Infinity;\n\n      for (let i = 0; i < slidesToUse.length; i++) {\n        const slide = slidesToUse[i];\n        const slideCenter = slide.offsetLeft + (slide.offsetWidth / 2);\n        const distance = Math.abs(centerPoint - slideCenter);\n        if (distance < closestDistance) {\n          closestDistance = distance;\n          closestSlide = slide;\n        }\n      }\n\n      if (closestSlide) {\n        closestSlide.classList.add('center');\n      }\n      return;\n    } else {\n      centerSlideIndex = this.currentSlide;\n    }\n\n    if (slidesToUse[centerSlideIndex]) {\n      slidesToUse[centerSlideIndex].classList.add('center');\n    }\n  }\n\n  /**\n     * Setup the autoplay.\n     *\n     * @returns {void}\n     */\n  setupAutoplay() {\n    if (this.currentOptions.autoplay) {\n      this.startAutoplay();\n\n      const self = this;\n      this.container.addEventListener('mouseenter', () => {\n        self.pauseAutoplay();\n      });\n      this.container.addEventListener('mouseleave', () => {\n        self.resumeAutoplay();\n      });\n    }\n  }\n\n  /**\n   * Enhanced autoplay for infinite scroll\n   *\n   * @returns {void}\n   */\n  startAutoplay() {\n    if (!this.currentOptions.autoplay) return;\n\n    this.stopAutoplay();\n    const self = this;\n\n    this.autoplayInterval = setInterval(() => {\n      if (!self.isScrolling) {\n        if (self.currentOptions.infinite) {\n          // For infinite mode, always use next() method which handles centerMode properly\n          const slideWidth = self.slides[0].offsetWidth + self.currentOptions.gap;\n          const scrollAmount = slideWidth * self.currentOptions.slidesToScroll;\n\n          if (self.currentOptions.centerMode) {\n            const currentCenterSlide = self.findCurrentCenterSlideIndex();\n            const nextCenterSlide = currentCenterSlide + self.currentOptions.slidesToScroll;\n            self.goToCenterSlide(nextCenterSlide);\n          } else {\n            self.track.scrollTo({\n              left: self.track.scrollLeft + scrollAmount,\n              behavior: 'smooth'\n            });\n          }\n        } else {\n          // Non-infinite modes use next() method\n          self.next();\n        }\n      }\n    }, this.currentOptions.autoplaySpeed);\n  }\n\n  /**\n     * Stop the autoplay.\n     *\n     * @returns {void}\n     */\n  stopAutoplay() {\n    if (this.autoplayInterval) {\n      clearInterval(this.autoplayInterval);\n      this.autoplayInterval = null;\n    }\n  }\n\n  /**\n     * Pause the autoplay.\n     *\n     * @returns {void}\n     */\n  pauseAutoplay() {\n    this.autoplayPaused = true;\n    this.stopAutoplay();\n  }\n\n  /**\n     * Resume the autoplay.\n     *\n     * @returns {void}\n     */\n  resumeAutoplay() {\n    if (this.currentOptions.autoplay && this.autoplayPaused) {\n      this.autoplayPaused = false;\n      const self = this;\n      setTimeout(() => {\n        if (!self.autoplayPaused && !self.isScrolling) {\n          self.startAutoplay();\n        }\n      }, 1000);\n    }\n  }\n\n  /**\n     * Handle the resize.\n     *\n     * @returns {void}\n     */\n  handleResize() {\n    const self = this;\n    setTimeout(() => {\n      // Store current responsive settings to detect changes.\n      const previousSlidesToShow = self.currentOptions.slidesToShow;\n      const previousShowOverflow = self.currentOptions.showOverflow;\n\n      // Update responsive settings first\n      self.setupResponsive();\n\n      // If pull-to-right setting changed, we need to reset styles\n      if (self.currentOptions.showOverflow !== previousShowOverflow) {\n        self.setupTrackStyles(); // This will apply or reset pull-to-right styles\n      } else if (self.currentOptions.showOverflow) {\n        // If still pull-to-right, just update padding\n        self.updatePullToRightPadding();\n      }\n\n      self.setupSlides();\n      self.calculateSlidePositions();\n\n      // Always reposition on resize, but use different logic based on responsive changes.\n      if (self.currentOptions.slidesToShow !== previousSlidesToShow) {\n        // If slidesToShow changed due to responsive breakpoint, reset to startSlide.\n        const targetSlide = self.currentOptions.startSlide || 0;\n        self.goToSlide(targetSlide);\n      } else {\n        // If slidesToShow didn't change, stay on current slide but reposition it.\n        self.goToSlide(self.currentSlide);\n      }\n    }, 100);\n  }\n\n  /**\n   * Enhanced destroy method to clean up infinite scroll timeouts\n   *\n   * @returns {void}\n   */\n  destroy() {\n    this.stopAutoplay();\n    clearTimeout(this.scrollTimeout);\n    clearTimeout(this.infiniteScrollTimeout);\n\n    // Clean up any cloned slides\n    if (this.track) {\n      const clones = this.track.querySelectorAll('.infinite-clone');\n      clones.forEach(clone => clone.remove());\n    }\n  }\n}\n\nexport default NativeScrollSlider;\n\n// Also make available globally when used in browser.\nif (typeof window !== 'undefined') {\n  window.NativeScrollSlider = NativeScrollSlider;\n}\n"],"names":["NativeScrollSlider","trackElement","options","element","passedOptions","defaults","dataConfig","e","selector","button","sliderControls","self","style","viewportWidth","containerMaxWidth","basePadding","leftPadding","width","currentOptions","sortedBreakpoints","a","b","i","breakpoint","containerWidth","totalGaps","slideWidth","overflowSlideWidth","totalNeededWidth","effectiveWidth","calculatedSlideWidth","minSlideWidth","minWidth","numericValue","mode","slidesToClone","originalIndex","clone","startIndex","initialPosition","trackStyles","trackPaddingLeft","trackPaddingRight","visibleTrackWidth","slidesPerView","clonesNeeded","slidesToUse","scrollLeft","adjustedScrollLeft","containerStyles","containerPaddingLeft","containerPaddingRight","containerInnerWidth","closestSlide","closestDistance","position","comparePosition","distance","cloneCount","targetIndex","totalOriginalWidth","leftBoundary","rightBoundary","equivalentPosition","slideIndex","targetPosition","newPosition","originalBehavior","gap","actualSlidesToShow","scrollAmount","nextCenterSlide","nextSlide","prevCenterSlide","prevSlide","centerPoint","slide","slideCenter","targetSlide","slideLeft","maxScroll","currentScroll","centerSlideIndex","previousSlidesToShow","previousShowOverflow"],"mappings":"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"}