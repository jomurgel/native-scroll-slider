{"version":3,"file":"native-scroll-slider.min.js","sources":["../src/index.js"],"sourcesContent":["/**\n * NativeScrollSlider\n *\n * A simple slider that leverages native overflow scroll behavior.\n *\n * @author Jo Murgel\n * @version 0.0.2\n * @license MIT\n * @copyright 2024 Jo Murgel\n * @see https://github.com/jomurgel/native-scroll-slider\n * @see https://www.npmjs.com/package/@jomurgel/native-scroll-slider\n */\nclass NativeScrollSlider {\n\n  /**\n     * Initialize the slider.\n     *\n     * @constructor\n     * @param {HTMLElement} trackElement - The track element containing the slides.\n     * @param {Object} options - The options for the slider.\n     * @returns {void}\n     */\n  constructor(trackElement, options = {}) {\n    // Safety checks\n    if (!trackElement) {\n      console.error('NativeScrollSlider: trackElement is null or undefined');\n      return;\n    }\n\n    this.track = trackElement;\n\n    // Find container - look up the DOM tree for a container with data-slider-config or use parent\n    this.container = this.findContainer(trackElement);\n\n    // Merge options: defaults < data-slider-config < passed options\n    this.options = this.buildConfig(options);\n\n    // Find slides within the track\n    this.slides = Array.from(this.track.children);\n\n    if (this.slides.length === 0) {\n      console.error('NativeScrollSlider: no slides found in track', this.track);\n      return;\n    }\n\n    // Find navigation buttons\n    this.prevBtn = this.findNavButton(this.options.prevElement);\n    this.nextBtn = this.findNavButton(this.options.nextElement);\n\n    this.currentSlide = 0;\n    this.totalSlides = this.slides.length;\n    this.autoplayInterval = null;\n    this.slidePositions = [];\n    this.isScrolling = false;\n    this.scrollTimeout = null;\n\n    this.init();\n  }\n\n  /**\n     * Find the container element by looking up the DOM tree\n     *\n     * @param {HTMLElement} trackElement\n     * @returns {HTMLElement}\n     */\n  findContainer(trackElement) {\n    let element = trackElement;\n\n    // Look up the DOM tree for an element with data-slider-config\n    while (element && element !== document.body) {\n      if (element.dataset.sliderConfig) {\n        return element;\n      }\n      element = element.parentElement;\n    }\n\n    // If no container with config found, use track's parent or track itself\n    return trackElement.parentElement || trackElement;\n  }\n\n  /**\n     * Build the configuration by merging defaults, data attributes, and passed options\n     *\n     * @param {Object} passedOptions\n     * @returns {Object}\n     */\n  buildConfig(passedOptions) {\n    // Default configuration\n    const defaults = {\n      slidesToShow: 4,\n      slidesToScroll: 1,\n      infinite: false,\n      bounceBack: false,\n      centerMode: false,\n      autoplay: false,\n      autoplaySpeed: 3000,\n      gap: 24,\n      startSlide: 0,\n      // @see https://dev.to/gerryleonugroho/responsive-design-breakpoints-2025-playbook-53ih\n      responsive: [\n        {\n          breakpoint: 1200,\n          settings: {\n            slidesToShow: 3\n          }\n        },\n        {\n          breakpoint: 992,\n          settings: {\n            slidesToShow: 2\n          }\n        },\n        {\n          breakpoint: 768,\n          settings: {\n            slidesToShow: 1\n          }\n        },\n        {\n          breakpoint: 576,\n          settings: {\n            slidesToShow: 1\n          }\n        }\n      ],\n      prevElement: '.prev, .slider-prev, .slider-grid-prev',\n      nextElement: '.next, .slider-next, .slider-grid-next',\n      minSlideWidth: 0,\n      showOverflow: false,\n      overflowAmount: 0.5,\n      containerMaxWidth: 1200,\n      basePadding: 35\n    };\n\n    // Try to get config from data attribute\n    let dataConfig = {};\n    if (this.container && this.container.dataset.sliderConfig) {\n      try {\n        dataConfig = JSON.parse(this.container.dataset.sliderConfig);\n      } catch (e) {\n        console.warn('NativeScrollSlider: Invalid JSON in data-slider-config', e);\n      }\n    }\n\n    // Merge: defaults < dataConfig < passedOptions\n    return Object.assign({}, defaults, dataConfig, passedOptions);\n  }\n\n  /**\n     * Find navigation button using querySelector\n     *\n     * @param {string} selector\n     * @returns {HTMLElement|null}\n     */\n  findNavButton(selector) {\n    if (!selector) return null;\n\n    // First try within container\n    let button = this.container.querySelector(selector);\n\n    // If not found, try within track\n    if (!button) {\n      button = this.track.querySelector(selector);\n    }\n\n    // If still not found, look for sibling .slider-controls container\n    if (!button && this.container.parentElement) {\n      const sliderControls = this.container.parentElement.querySelector('.slider-controls');\n      if (sliderControls) {\n        // Look for the specific prev/next button within slider-controls\n        if (selector.includes('prev')) {\n          button = sliderControls.querySelector('.slider-prev');\n        } else if (selector.includes('next')) {\n          button = sliderControls.querySelector('.slider-next');\n        }\n      }\n    }\n\n    return button;\n  }\n\n  /**\n     * Initialize the slider.\n     *\n     * @returns {void}\n     */\n  init() {\n    // Setup responsive settings FIRST\n    this.setupResponsive();\n\n    // Now we can setup track styles with correct currentOptions\n    this.setupTrackStyles();\n\n    this.setupSlides();\n    this.calculateSlidePositions();\n    this.setupNavigation();\n    this.setupScrollListener();\n    this.setupAutoplay();\n\n    const self = this;\n    window.addEventListener('resize', () => {\n      self.handleResize();\n    });\n\n    this.container.classList.add('slider-ready');\n\n    setTimeout(() => {\n      self.goToSlide(self.currentOptions.startSlide);\n    }, 50);\n\n    this.updateCurrentSlideFromScroll();\n  }\n\n  /**\n     * Setup basic track styles for horizontal scrolling\n     *\n     * @returns {void}\n     */\n  setupTrackStyles() {\n    this.track.style.display = 'flex';\n    this.track.style.overflowX = 'auto';\n    this.track.style.scrollBehavior = 'smooth';\n    this.track.style.scrollbarWidth = 'none';\n    this.track.style.msOverflowStyle = 'none';\n\n    // Setup or reset pull-to-right styles based on current options\n    if (this.currentOptions.showOverflow) {\n      this.setupPullToRightStyles();\n    } else {\n      this.resetPullToRightStyles();\n    }\n\n    // Hide webkit scrollbars\n    if (!document.getElementById('native-scroll-slider-styles')) {\n      const style = document.createElement('style');\n      style.id = 'native-scroll-slider-styles';\n      style.textContent = `\n\t\t\t\t\t\t  .slider-ready .slider-track::-webkit-scrollbar,\n\t\t\t\t\t\t  [data-slider-config] > *::-webkit-scrollbar {\n\t\t\t\t\t\t\t  display: none;\n\t\t\t\t\t\t  }\n\t\t\t\t\t  `;\n      document.head.appendChild(style);\n    }\n  }\n\n  /**\n     * Setup pull-to-right styles to break out to viewport width\n     *\n     * @returns {void}\n     */\n  setupPullToRightStyles() {\n    // Break container out to full viewport width\n    this.container.style.width = '100vw';\n    this.container.style.position = 'relative';\n    this.container.style.left = '50%';\n    this.container.style.right = '50%';\n    this.container.style.marginLeft = '-50vw';\n    this.container.style.marginRight = '-50vw';\n\n    // Calculate left padding to maintain alignment with page content\n    this.updatePullToRightPadding();\n  }\n\n  /**\n     * Reset pull-to-right styles when disabled\n     *\n     * @returns {void}\n     */\n  resetPullToRightStyles() {\n    // Reset container styles\n    this.container.style.width = '';\n    this.container.style.position = '';\n    this.container.style.left = '';\n    this.container.style.right = '';\n    this.container.style.marginLeft = '';\n    this.container.style.marginRight = '';\n\n    // Reset track padding - it will be recalculated in setupSlides\n    this.track.style.paddingLeft = '';\n    this.track.style.paddingRight = '';\n\n    // Clear stored padding\n    this.pullToRightLeftPadding = 0;\n  }\n\n  /**\n     * Update pull-to-right padding based on viewport and container size\n     *\n     * @returns {void}\n     */\n  updatePullToRightPadding() {\n    if (!this.currentOptions.showOverflow) {\n      return;\n    }\n\n    const viewportWidth = window.innerWidth;\n    const containerMaxWidth = this.currentOptions.containerMaxWidth; // Use currentOptions\n    const basePadding = this.currentOptions.basePadding; // Use currentOptions\n\n    let leftPadding;\n\n    if (viewportWidth <= containerMaxWidth + (basePadding * 2)) {\n      // On smaller screens, just use base padding\n      leftPadding = basePadding;\n    } else {\n      // On larger screens, calculate padding to align with page content\n      leftPadding = Math.max(basePadding, (viewportWidth - containerMaxWidth) / 2 + basePadding);\n    }\n\n    // Apply the calculated padding\n    this.track.style.paddingLeft = leftPadding + 'px';\n    this.track.style.paddingRight = basePadding + 'px';\n\n    // Store the calculated padding for use in slide calculations\n    this.pullToRightLeftPadding = leftPadding;\n  }\n\n  /**\n   * Setup the responsive settings.\n   *\n   * @returns {void}\n   */\n  setupResponsive() {\n    const width = window.innerWidth;\n    let currentOptions = Object.assign({}, this.options);\n\n    // Sort responsive breakpoints in descending order (largest first)\n    const sortedBreakpoints = [...this.options.responsive].sort((a, b) => b.breakpoint - a.breakpoint);\n\n    // Apply settings from all matching breakpoints in cascade (largest to smallest)\n    for (let i = 0; i < sortedBreakpoints.length; i++) {\n      const breakpoint = sortedBreakpoints[i];\n      if (width <= breakpoint.breakpoint) {\n        // Apply this breakpoint's settings on top of previous settings\n        currentOptions = Object.assign(currentOptions, breakpoint.settings);\n        // Don't break - continue to apply smaller breakpoints too\n      }\n    }\n\n    this.currentOptions = currentOptions;\n  }\n\n  /**\n   * Setup the slides.\n   *\n   * @returns {void}\n   */\n  setupSlides() {\n    if (!this.track) {\n      console.error('setupSlides: track is null');\n      return;\n    }\n\n    this.track.style.gap = this.currentOptions.gap + 'px';\n\n    if (!this.container) {\n      console.error('setupSlides: container is null');\n      return;\n    }\n\n    let containerWidth = this.container.offsetWidth;\n    let leftPadding, totalGaps, slideWidth, overflowSlideWidth, totalNeededWidth;\n\n    // Handle pull-to-right mode\n    if (this.currentOptions.showOverflow) {\n      // Update padding first\n      this.updatePullToRightPadding();\n\n      // Use viewport width for calculations since container is now 100vw\n      containerWidth = window.innerWidth;\n\n      // Account for the left padding we applied\n      const effectiveWidth = containerWidth - this.pullToRightLeftPadding - this.currentOptions.basePadding;\n\n      totalGaps = (this.currentOptions.slidesToShow - 1) * this.currentOptions.gap;\n      overflowSlideWidth = 0;\n\n      if (this.currentOptions.overflowAmount > 0) {\n        const tempSlideWidth = (effectiveWidth - totalGaps - this.currentOptions.gap) / (this.currentOptions.slidesToShow + this.currentOptions.overflowAmount);\n        overflowSlideWidth = tempSlideWidth * this.currentOptions.overflowAmount;\n      }\n\n      let calculatedSlideWidth = (effectiveWidth - totalGaps - overflowSlideWidth) / this.currentOptions.slidesToShow;\n\n      // Apply minSlideWidth if defined - force it regardless of slidesToShow\n      const minSlideWidth = this.parseMinSlideWidth();\n      if (minSlideWidth > 0 && calculatedSlideWidth < minSlideWidth) {\n        slideWidth = minSlideWidth;\n\n        // Calculate how many slides can actually fit at this minimum width\n        // For overflow mode, we need to account for the overflow space too\n        // const availableForSlides = effectiveWidth - overflowSlideWidth;\n        // const maxSlidesAtMinWidth = Math.floor((availableForSlides + this.currentOptions.gap) / (minSlideWidth + this.currentOptions.gap));\n        // const actualSlidesToShow = Math.max(1, Math.min(maxSlidesAtMinWidth, this.currentOptions.slidesToShow));\n      } else {\n        slideWidth = calculatedSlideWidth;\n      }\n\n      // Don't add additional padding - we already set it in updatePullToRightPadding\n      leftPadding = 0;\n    } else {\n      // Regular mode\n      totalGaps = (this.currentOptions.slidesToShow - 1) * this.currentOptions.gap;\n      let calculatedSlideWidth = (containerWidth - totalGaps) / this.currentOptions.slidesToShow;\n\n      // Apply minSlideWidth constraint - force the width but don't change slide count\n      const minSlideWidth = this.parseMinSlideWidth();\n      if (minSlideWidth > 0 && calculatedSlideWidth < minSlideWidth) {\n        slideWidth = minSlideWidth;\n\n        // Keep original slidesToShow but recalculate total needed width\n        totalNeededWidth = (slideWidth * this.currentOptions.slidesToShow) + totalGaps;\n\n        if (this.currentOptions.centerMode) {\n          // For center mode, center the content within container\n          leftPadding = Math.max(0, (containerWidth - totalNeededWidth) / 2);\n        } else {\n          // For non-center mode, allow overflow - align left with minimal padding\n          leftPadding = Math.max(0, (containerWidth - totalNeededWidth) / 2);\n        }\n      } else {\n        // No minWidth constraint or already meets it\n        slideWidth = calculatedSlideWidth;\n        totalNeededWidth = (slideWidth * this.currentOptions.slidesToShow) + totalGaps;\n        leftPadding = Math.max(0, (containerWidth - totalNeededWidth) / 2);\n      }\n\n      // Apply padding to track\n      this.track.style.paddingLeft = leftPadding + 'px';\n      this.track.style.paddingRight = leftPadding + 'px';\n    }\n\n    // Apply slide widths\n    for (let i = 0; i < this.slides.length; i++) {\n      if (this.slides[i] && this.slides[i].style) {\n        this.slides[i].style.width = slideWidth + 'px';\n        this.slides[i].style.flexShrink = '0';\n      }\n    }\n\n    if ((this.currentOptions.infinite || this.currentOptions.bounceBack) && this.totalSlides > this.currentOptions.slidesToShow) {\n      if (this.currentOptions.infinite) {\n        this.setupTrueInfinite();\n      } else if (this.currentOptions.bounceBack) {\n        this.setupBounceBack();\n      }\n    }\n  }\n\n  /**\n   * Parse minSlideWidth from string or number\n   *\n   * @returns {number}\n   */\n  parseMinSlideWidth() {\n    if (!this.currentOptions.minSlideWidth) return 0;\n\n    const minWidth = this.currentOptions.minSlideWidth;\n    if (typeof minWidth === 'string') {\n      // Handle \"0px\", \"100px\", etc.\n      const numericValue = parseFloat(minWidth);\n      return isNaN(numericValue) ? 0 : numericValue;\n    }\n\n    return typeof minWidth === 'number' ? minWidth : 0;\n  }\n\n  /**\n   * Setup bounce back or infinite mode\n   *\n   * @param {string} mode - 'bounce' or 'infinite'\n   * @returns {void}\n   */\n  setupClonedSlides(mode) {\n    const slidesToClone = mode === 'infinite'\n      ? this.currentOptions.slidesToShow + 1\n      : Math.max(this.currentOptions.slidesToShow, 2);\n\n    if (mode === 'infinite') {\n      // Clone slides to end\n      for (let i = 0; i < slidesToClone; i++) {\n        const originalIndex = i % this.totalSlides;\n        const clone = this.slides[originalIndex].cloneNode(true);\n        clone.classList.add('cloned', 'infinite-clone');\n        clone.dataset.originalIndex = originalIndex;\n        this.track.appendChild(clone);\n      }\n\n      // Clone slides to beginning\n      for (let i = 0; i < slidesToClone; i++) {\n        const originalIndex = (this.totalSlides - slidesToClone + i) % this.totalSlides;\n        const clone = this.slides[originalIndex].cloneNode(true);\n        clone.classList.add('cloned', 'infinite-clone');\n        clone.dataset.originalIndex = originalIndex;\n        this.track.insertBefore(clone, this.track.firstChild);\n      }\n\n      this.initialCloneCount = slidesToClone;\n    } else {\n      // Bounce mode: clone to end\n      for (let i = 0; i < slidesToClone; i++) {\n        const clone = this.slides[i].cloneNode(true);\n        clone.classList.add('cloned', 'bounce-clone');\n        this.track.appendChild(clone);\n      }\n\n      // Clone to beginning\n      for (let i = this.totalSlides - slidesToClone; i < this.totalSlides; i++) {\n        const clone = this.slides[i].cloneNode(true);\n        clone.classList.add('cloned', 'bounce-clone');\n        this.track.insertBefore(clone, this.track.firstChild);\n      }\n    }\n\n    this.allSlides = Array.from(this.track.children);\n\n    // Set initial position after DOM updates\n    const self = this;\n    setTimeout(() => {\n      self.calculateSlidePositions();\n\n      const startIndex = mode === 'infinite'\n        ? slidesToClone + self.currentOptions.startSlide\n        : slidesToClone + self.currentOptions.startSlide;\n\n      let initialPosition = self.slidePositions[startIndex];\n\n      // Apply centerMode calculations if needed\n      if (self.currentOptions.centerMode) {\n        const trackStyles = window.getComputedStyle(self.track);\n        const trackPaddingLeft = parseFloat(trackStyles.paddingLeft) || 0;\n        const trackPaddingRight = parseFloat(trackStyles.paddingRight) || 0;\n        const visibleTrackWidth = self.track.offsetWidth - trackPaddingLeft - trackPaddingRight;\n\n        const slideWidth = self.slides[0].offsetWidth;\n        initialPosition = initialPosition - (visibleTrackWidth / 2) + (slideWidth / 2);\n      }\n\n      self.track.scrollLeft = initialPosition;\n      self.currentSlide = self.currentOptions.startSlide;\n    }, 10);\n  }\n\n  /**\n   * Setup the bounce back.\n   *\n   * @returns {void}\n   */\n  setupBounceBack() {\n    this.setupClonedSlides('bounce');\n  }\n\n  /**\n   * Setup the true infinite scroll with a simpler, more reliable approach\n   *\n   * @returns {void}\n   */\n  setupTrueInfinite() {\n    // Calculate how many clones we need for smooth infinite scrolling\n    // We need enough clones on each side to handle the maximum scroll distance\n    const containerWidth = this.container.offsetWidth;\n    const slideWidth = this.slides[0].offsetWidth + this.currentOptions.gap;\n    const slidesPerView = Math.ceil(containerWidth / slideWidth);\n\n    // Create enough clones to fill at least 2 viewport widths on each side\n    const clonesNeeded = Math.max(this.totalSlides, slidesPerView * 2);\n\n    this.initialCloneCount = clonesNeeded;\n\n    // Clone slides to the end\n    for (let i = 0; i < clonesNeeded; i++) {\n      const originalIndex = i % this.totalSlides;\n      const clone = this.slides[originalIndex].cloneNode(true);\n      clone.classList.add('cloned', 'infinite-clone');\n      clone.dataset.originalIndex = originalIndex;\n      this.track.appendChild(clone);\n    }\n\n    // Clone slides to the beginning\n    for (let i = 0; i < clonesNeeded; i++) {\n      const originalIndex = (this.totalSlides - 1 - (i % this.totalSlides)) % this.totalSlides;\n      const clone = this.slides[originalIndex].cloneNode(true);\n      clone.classList.add('cloned', 'infinite-clone');\n      clone.dataset.originalIndex = originalIndex;\n      this.track.insertBefore(clone, this.track.firstChild);\n    }\n\n    this.allSlides = Array.from(this.track.children);\n\n    // Set initial position after DOM updates\n    const self = this;\n    setTimeout(() => {\n      self.calculateSlidePositions();\n\n      // Start in the middle section (original slides)\n      const startIndex = clonesNeeded + self.currentOptions.startSlide;\n      let initialPosition = self.slidePositions[startIndex];\n\n      // Apply centerMode calculations if needed\n      if (self.currentOptions.centerMode) {\n        const trackStyles = window.getComputedStyle(self.track);\n        const trackPaddingLeft = parseFloat(trackStyles.paddingLeft) || 0;\n        const trackPaddingRight = parseFloat(trackStyles.paddingRight) || 0;\n        const visibleTrackWidth = self.track.offsetWidth - trackPaddingLeft - trackPaddingRight;\n        const slideWidth = self.slides[0].offsetWidth;\n        initialPosition = initialPosition - (visibleTrackWidth / 2) + (slideWidth / 2);\n      }\n\n      // Disable smooth scrolling temporarily for initial positioning\n      self.track.style.scrollBehavior = 'auto';\n      self.track.scrollLeft = initialPosition;\n      self.track.style.scrollBehavior = 'smooth';\n\n      self.currentSlide = self.currentOptions.startSlide;\n      self.infiniteScrollSetup = true;\n    }, 10);\n  }\n\n  /**\n     * Calculate the slide positions.\n     *\n     * @returns {void}\n     */\n  calculateSlidePositions() {\n    this.slidePositions = [];\n    const slidesToUse = this.allSlides || this.slides;\n    const leftPadding = parseFloat(this.track.style.paddingLeft) || 0;\n\n    for (let i = 0; i < slidesToUse.length; i++) {\n      this.slidePositions.push(slidesToUse[i].offsetLeft - leftPadding);\n    }\n  }\n\n  /**\n   * Enhanced scroll listener for infinite scroll\n   *\n   * @returns {void}\n   */\n  setupScrollListener() {\n    const self = this;\n\n    this.track.addEventListener('scroll', () => {\n      self.isScrolling = true;\n      self.pauseAutoplay();\n\n      // Handle infinite scroll with debouncing\n      if (self.currentOptions.infinite) {\n        clearTimeout(self.infiniteScrollTimeout);\n        self.infiniteScrollTimeout = setTimeout(() => {\n          self.handleInfiniteScroll();\n        }, 50); // Quick response for seamless experience\n      }\n\n      clearTimeout(self.scrollTimeout);\n      self.scrollTimeout = setTimeout(() => {\n        self.isScrolling = false;\n        self.resumeAutoplay();\n      }, 150);\n\n      self.updateCurrentSlideFromScroll();\n    }, { passive: true });\n  }\n\n  /**\n   * Update the current slide from the scroll.\n   *\n   * @returns {void}\n   */\n  updateCurrentSlideFromScroll() {\n    const scrollLeft = this.track.scrollLeft;\n\n    // For infinite mode, don't track slides - just let it scroll freely.\n    if (this.currentOptions.infinite) {\n      this.updateCenterMode();\n      return;\n    }\n\n    let adjustedScrollLeft = scrollLeft;\n    if (this.currentOptions.centerMode) {\n      // Get actual container dimensions accounting for padding\n      const containerStyles = window.getComputedStyle(this.container);\n      const containerPaddingLeft = parseFloat(containerStyles.paddingLeft) || 0;\n      const containerPaddingRight = parseFloat(containerStyles.paddingRight) || 0;\n      const containerInnerWidth = this.container.offsetWidth - containerPaddingLeft - containerPaddingRight;\n\n      // Adjust scroll position to account for centering and container padding\n      adjustedScrollLeft = scrollLeft + (containerInnerWidth / 2) + containerPaddingLeft;\n    }\n\n    let closestSlide = 0;\n    let closestDistance = Infinity;\n\n    for (let i = 0; i < this.slidePositions.length; i++) {\n      const position = this.slidePositions[i];\n      let comparePosition = position;\n      if (this.currentOptions.centerMode) {\n        const slideWidth = this.slides[0].offsetWidth;\n        comparePosition = position + (slideWidth / 2);\n      }\n\n      const distance = Math.abs(adjustedScrollLeft - comparePosition);\n      if (distance < closestDistance) {\n        closestDistance = distance;\n        closestSlide = i;\n      }\n    }\n\n    if (this.currentOptions.bounceBack && this.allSlides) {\n      const cloneCount = Math.max(this.currentOptions.slidesToShow, 2);\n      if (closestSlide >= cloneCount && closestSlide < cloneCount + this.totalSlides) {\n        this.currentSlide = closestSlide - cloneCount;\n      }\n    } else {\n      this.currentSlide = closestSlide;\n    }\n\n    this.updateNavigation();\n    this.updateCenterMode();\n  }\n\n  /**\n     * Handle the scroll end.\n     *\n     * @returns {void}\n     */\n  handleScrollEnd() {\n    if (this.currentOptions.bounceBack) {\n      this.handleBounceBackScroll();\n    } else if (this.currentOptions.infinite) {\n      this.handleInfiniteScroll();\n    }\n  }\n\n  /**\n     * Handle the bounce back scroll.\n     *\n     * @returns {void}\n     */\n  handleBounceBackScroll() {\n    const cloneCount = Math.max(this.currentOptions.slidesToShow, 2);\n    const scrollLeft = this.track.scrollLeft;\n    const slideWidth = this.slides[0].offsetWidth + this.currentOptions.gap;\n\n    if (scrollLeft < cloneCount * slideWidth / 2) {\n      const targetIndex = cloneCount + this.totalSlides - (cloneCount - Math.floor(scrollLeft / slideWidth));\n      this.track.scrollLeft = this.slidePositions[targetIndex];\n    } else if (scrollLeft > this.slidePositions[cloneCount + this.totalSlides - 1]) {\n      const targetIndex = cloneCount + (this.currentSlide % this.totalSlides);\n      this.track.scrollLeft = this.slidePositions[targetIndex];\n    }\n  }\n\n  /**\n   * Handle infinite scroll with seamless looping\n   *\n   * @returns {void}\n   */\n  handleInfiniteScroll() {\n    if (!this.infiniteScrollSetup) return;\n\n    const scrollLeft = this.track.scrollLeft;\n    const slideWidth = this.slides[0].offsetWidth + this.currentOptions.gap;\n    const totalOriginalWidth = this.totalSlides * slideWidth;\n\n    // Calculate the boundaries where we need to \"teleport\"\n    const leftBoundary = slideWidth * 2; // 2 slides worth of buffer\n    const rightBoundary = this.slidePositions[this.initialCloneCount + this.totalSlides] - slideWidth * 2;\n\n    // If we've scrolled too far left, jump to the equivalent position on the right\n    if (scrollLeft <= leftBoundary) {\n      const equivalentPosition = scrollLeft + totalOriginalWidth;\n      this.seamlessJump(equivalentPosition);\n    }\n    // If we've scrolled too far right, jump to the equivalent position on the left\n    else if (scrollLeft >= rightBoundary) {\n      const equivalentPosition = scrollLeft - totalOriginalWidth;\n      this.seamlessJump(equivalentPosition);\n    }\n  }\n\n  /**\n     * Setup the navigation.\n     *\n     * @returns {void}\n     */\n  setupNavigation() {\n    const self = this;\n    if (this.prevBtn) {\n      this.prevBtn.addEventListener('click', () => {\n        self.prev();\n      });\n    }\n\n    if (this.nextBtn) {\n      this.nextBtn.addEventListener('click', () => {\n        self.next();\n      });\n    }\n\n    this.updateNavigation();\n  }\n\n  /**\n   * Go to the slide.\n   *\n   * @param {number} slideIndex - The index of the slide to go to.\n   * @returns {void}\n   */\n  goToSlide(slideIndex) {\n    // For infinite mode, don't use goToSlide - just use next/prev buttons.\n    if (this.currentOptions.infinite) {\n      return;\n    }\n\n    if (slideIndex < 0 || slideIndex >= this.totalSlides) return;\n\n    let targetPosition;\n\n    if (this.currentOptions.bounceBack) {\n      const cloneCount = Math.max(this.currentOptions.slidesToShow, 2);\n      targetPosition = this.slidePositions[cloneCount + slideIndex];\n    } else {\n      targetPosition = this.slidePositions[slideIndex];\n    }\n\n    if (this.currentOptions.centerMode) {\n      // Get actual container dimensions accounting for padding\n      const containerStyles = window.getComputedStyle(this.container);\n      const containerPaddingLeft = parseFloat(containerStyles.paddingLeft) || 0;\n      const containerPaddingRight = parseFloat(containerStyles.paddingRight) || 0;\n      const containerInnerWidth = this.container.offsetWidth - containerPaddingLeft - containerPaddingRight;\n\n      const slideWidth = this.slides[0].offsetWidth;\n\n      // Center the slide within the container's inner width\n      targetPosition = targetPosition - (containerInnerWidth / 2) + (slideWidth / 2);\n\n      // Account for container padding offset in scroll position\n      targetPosition = targetPosition - containerPaddingLeft;\n    }\n\n    this.track.scrollTo({\n      left: targetPosition,\n      behavior: 'smooth'\n    });\n\n    this.currentSlide = slideIndex;\n  }\n\n  /**\n   * Perform a seamless jump to maintain infinite scroll illusion\n   *\n   * @param {number} newPosition - The new scroll position\n   * @returns {void}\n   */\n  seamlessJump(newPosition) {\n    // Temporarily disable smooth scrolling for the jump\n    const originalBehavior = this.track.style.scrollBehavior;\n    this.track.style.scrollBehavior = 'auto';\n\n    // Perform the jump\n    this.track.scrollLeft = newPosition;\n\n    // Re-enable smooth scrolling after a small delay\n    setTimeout(() => {\n      this.track.style.scrollBehavior = originalBehavior || 'smooth';\n    }, 10);\n  }\n\n  /**\n   * Calculate how many slides are actually visible in the current viewport\n   * @returns {number}\n   */\n  getActualSlidesToShow() {\n    if (!this.slides.length) return this.currentOptions.slidesToShow;\n\n    const containerWidth = this.container.offsetWidth;\n    const slideWidth = this.slides[0].offsetWidth;\n    const gap = this.currentOptions.gap;\n\n    // Calculate how many slides actually fit in the visible area\n    const actualSlidesToShow = Math.floor((containerWidth + gap) / (slideWidth + gap));\n\n    // Return the smaller of configured vs actual\n    return Math.min(actualSlidesToShow, this.currentOptions.slidesToShow);\n  }\n\n  /**\n   * Enhanced next method for infinite scroll\n   *\n   * @returns {void}\n   */\n  next() {\n    // For infinite mode, just scroll by the specified amount\n    if (this.currentOptions.infinite) {\n      const slideWidth = this.slides[0].offsetWidth + this.currentOptions.gap;\n      const scrollAmount = slideWidth * this.currentOptions.slidesToScroll;\n\n      if (this.currentOptions.centerMode) {\n        // For center mode, we need to find the current center slide and go to the next one\n        const currentCenterSlide = this.findCurrentCenterSlideIndex();\n        const nextCenterSlide = currentCenterSlide + this.currentOptions.slidesToScroll;\n        this.goToCenterSlide(nextCenterSlide);\n      } else {\n        this.track.scrollTo({\n          left: this.track.scrollLeft + scrollAmount,\n          behavior: 'smooth'\n        });\n      }\n      return;\n    }\n\n    const actualSlidesToShow = this.getActualSlidesToShow();\n\n    // Non-infinite mode logic remains the same\n    let nextSlide;\n    if (this.currentOptions.bounceBack) {\n      nextSlide = (this.currentSlide + this.currentOptions.slidesToScroll) % this.totalSlides;\n    } else {\n      // Use actualSlidesToShow instead of this.currentOptions.slidesToShow\n      nextSlide = Math.min(\n        this.currentSlide + this.currentOptions.slidesToScroll,\n        this.totalSlides - actualSlidesToShow\n      );\n    }\n\n    this.goToSlide(nextSlide);\n  }\n\n  /**\n   * Enhanced prev method for infinite scroll\n   *\n   * @returns {void}\n   */\n  prev() {\n    // For infinite mode, just scroll by the specified amount\n    if (this.currentOptions.infinite) {\n      const slideWidth = this.slides[0].offsetWidth + this.currentOptions.gap;\n      const scrollAmount = slideWidth * this.currentOptions.slidesToScroll;\n\n      if (this.currentOptions.centerMode) {\n        // For center mode, we need to find the current center slide and go to the previous one\n        const currentCenterSlide = this.findCurrentCenterSlideIndex();\n        const prevCenterSlide = currentCenterSlide - this.currentOptions.slidesToScroll;\n        this.goToCenterSlide(prevCenterSlide);\n      } else {\n        this.track.scrollTo({\n          left: this.track.scrollLeft - scrollAmount,\n          behavior: 'smooth'\n        });\n      }\n      return;\n    }\n\n    // Non-infinite mode logic remains the same\n    let prevSlide;\n    if (this.currentOptions.bounceBack) {\n      prevSlide = this.currentSlide - this.currentOptions.slidesToScroll;\n      if (prevSlide < 0) {\n        prevSlide = this.totalSlides + prevSlide;\n      }\n    } else {\n      prevSlide = Math.max(this.currentSlide - this.currentOptions.slidesToScroll, 0);\n    }\n\n    this.goToSlide(prevSlide);\n  }\n\n  /**\n   * Find the index of the currently centered slide in infinite mode\n   *\n   * @returns {number}\n   */\n  findCurrentCenterSlideIndex() {\n    const scrollLeft = this.track.scrollLeft;\n    const trackStyles = window.getComputedStyle(this.track);\n    const trackPaddingLeft = parseFloat(trackStyles.paddingLeft) || 0;\n    const visibleTrackWidth = this.track.offsetWidth - trackPaddingLeft - (parseFloat(trackStyles.paddingRight) || 0);\n\n    // Find the center point of the visible area\n    const centerPoint = scrollLeft + (visibleTrackWidth / 2);\n\n    let closestSlide = 0;\n    let closestDistance = Infinity;\n\n    const slidesToUse = this.allSlides || this.slides;\n    for (let i = 0; i < slidesToUse.length; i++) {\n      const slide = slidesToUse[i];\n      const slideCenter = slide.offsetLeft + (slide.offsetWidth / 2) - trackPaddingLeft;\n      const distance = Math.abs(centerPoint - slideCenter);\n\n      if (distance < closestDistance) {\n        closestDistance = distance;\n        closestSlide = i;\n      }\n    }\n\n    return closestSlide;\n  }\n\n  /**\n   * Go to a specific slide index and center it (for infinite mode)\n   *\n   * @param {number} slideIndex\n   * @returns {void}\n   */\n  goToCenterSlide(slideIndex) {\n    const slidesToUse = this.allSlides || this.slides;\n\n    // Make sure index is within bounds\n    if (slideIndex < 0 || slideIndex >= slidesToUse.length) {\n      return;\n    }\n\n    const targetSlide = slidesToUse[slideIndex];\n    const trackStyles = window.getComputedStyle(this.track);\n    const trackPaddingLeft = parseFloat(trackStyles.paddingLeft) || 0;\n    const trackPaddingRight = parseFloat(trackStyles.paddingRight) || 0;\n    const visibleTrackWidth = this.track.offsetWidth - trackPaddingLeft - trackPaddingRight;\n\n    // Calculate position to center this slide\n    const slideLeft = targetSlide.offsetLeft - trackPaddingLeft;\n    const slideWidth = targetSlide.offsetWidth;\n    const targetPosition = slideLeft - (visibleTrackWidth / 2) + (slideWidth / 2);\n\n    this.track.scrollTo({\n      left: targetPosition,\n      behavior: 'smooth'\n    });\n  }\n\n  /**\n     * Update the navigation.\n     *\n     * @returns {void}\n     */\n  updateNavigation() {\n    if (!this.prevBtn || !this.nextBtn) return;\n\n    // For infinite mode, buttons are always enabled\n    if (this.currentOptions.infinite) {\n      this.prevBtn.disabled = false;\n      this.nextBtn.disabled = false;\n      return;\n    }\n\n    if (this.currentOptions.bounceBack) {\n      this.prevBtn.disabled = false;\n      this.nextBtn.disabled = false;\n    } else {\n      this.prevBtn.disabled = this.currentSlide === 0;\n\n      // Calculate the actual last scrollable position\n      const maxScroll = this.track.scrollWidth - this.track.clientWidth;\n      const currentScroll = this.track.scrollLeft;\n\n      // Disable next if we can't scroll further right\n      // Add a small buffer (5px) to account for rounding errors\n      this.nextBtn.disabled = currentScroll >= maxScroll - 5;\n    }\n  }\n\n  /**\n     * Update the center mode.\n     *\n     * @returns {void}\n     */\n  updateCenterMode() {\n    if (!this.currentOptions.centerMode) return;\n\n    const slidesToUse = this.allSlides || this.slides;\n    for (let i = 0; i < slidesToUse.length; i++) {\n      slidesToUse[i].classList.remove('center');\n    }\n\n    let centerSlideIndex;\n    if (this.currentOptions.bounceBack) {\n      const cloneCount = Math.max(this.currentOptions.slidesToShow, 2);\n      centerSlideIndex = cloneCount + this.currentSlide;\n    } else if (this.currentOptions.infinite) {\n      const scrollLeft = this.track.scrollLeft;\n      const containerWidth = this.container.offsetWidth;\n      const centerPoint = scrollLeft + (containerWidth / 2);\n\n      let closestSlide = null;\n      let closestDistance = Infinity;\n\n      for (let i = 0; i < slidesToUse.length; i++) {\n        const slide = slidesToUse[i];\n        const slideCenter = slide.offsetLeft + (slide.offsetWidth / 2);\n        const distance = Math.abs(centerPoint - slideCenter);\n        if (distance < closestDistance) {\n          closestDistance = distance;\n          closestSlide = slide;\n        }\n      }\n\n      if (closestSlide) {\n        closestSlide.classList.add('center');\n      }\n      return;\n    } else {\n      centerSlideIndex = this.currentSlide;\n    }\n\n    if (slidesToUse[centerSlideIndex]) {\n      slidesToUse[centerSlideIndex].classList.add('center');\n    }\n  }\n\n  /**\n     * Setup the autoplay.\n     *\n     * @returns {void}\n     */\n  setupAutoplay() {\n    if (this.currentOptions.autoplay) {\n      this.startAutoplay();\n\n      const self = this;\n      this.container.addEventListener('mouseenter', () => {\n        self.pauseAutoplay();\n      });\n      this.container.addEventListener('mouseleave', () => {\n        self.resumeAutoplay();\n      });\n    }\n  }\n\n  /**\n   * Enhanced autoplay for infinite scroll\n   *\n   * @returns {void}\n   */\n  startAutoplay() {\n    if (!this.currentOptions.autoplay) return;\n\n    this.stopAutoplay();\n    const self = this;\n\n    this.autoplayInterval = setInterval(() => {\n      if (!self.isScrolling) {\n        if (self.currentOptions.infinite) {\n          // For infinite mode, always use next() method which handles centerMode properly\n          const slideWidth = self.slides[0].offsetWidth + self.currentOptions.gap;\n          const scrollAmount = slideWidth * self.currentOptions.slidesToScroll;\n\n          if (self.currentOptions.centerMode) {\n            const currentCenterSlide = self.findCurrentCenterSlideIndex();\n            const nextCenterSlide = currentCenterSlide + self.currentOptions.slidesToScroll;\n            self.goToCenterSlide(nextCenterSlide);\n          } else {\n            self.track.scrollTo({\n              left: self.track.scrollLeft + scrollAmount,\n              behavior: 'smooth'\n            });\n          }\n        } else {\n          // Non-infinite modes use next() method\n          self.next();\n        }\n      }\n    }, this.currentOptions.autoplaySpeed);\n  }\n\n  /**\n     * Stop the autoplay.\n     *\n     * @returns {void}\n     */\n  stopAutoplay() {\n    if (this.autoplayInterval) {\n      clearInterval(this.autoplayInterval);\n      this.autoplayInterval = null;\n    }\n  }\n\n  /**\n     * Pause the autoplay.\n     *\n     * @returns {void}\n     */\n  pauseAutoplay() {\n    this.autoplayPaused = true;\n    this.stopAutoplay();\n  }\n\n  /**\n     * Resume the autoplay.\n     *\n     * @returns {void}\n     */\n  resumeAutoplay() {\n    if (this.currentOptions.autoplay && this.autoplayPaused) {\n      this.autoplayPaused = false;\n      const self = this;\n      setTimeout(() => {\n        if (!self.autoplayPaused && !self.isScrolling) {\n          self.startAutoplay();\n        }\n      }, 1000);\n    }\n  }\n\n  /**\n     * Handle the resize.\n     *\n     * @returns {void}\n     */\n  handleResize() {\n    const self = this;\n    setTimeout(() => {\n      // Store current responsive settings to detect changes.\n      const previousSlidesToShow = self.currentOptions.slidesToShow;\n      const previousShowOverflow = self.currentOptions.showOverflow;\n\n      // Update responsive settings first\n      self.setupResponsive();\n\n      // If pull-to-right setting changed, we need to reset styles\n      if (self.currentOptions.showOverflow !== previousShowOverflow) {\n        self.setupTrackStyles(); // This will apply or reset pull-to-right styles\n      } else if (self.currentOptions.showOverflow) {\n        // If still pull-to-right, just update padding\n        self.updatePullToRightPadding();\n      }\n\n      self.setupSlides();\n      self.calculateSlidePositions();\n\n      // Always reposition on resize, but use different logic based on responsive changes.\n      if (self.currentOptions.slidesToShow !== previousSlidesToShow) {\n        // If slidesToShow changed due to responsive breakpoint, reset to startSlide.\n        const targetSlide = self.currentOptions.startSlide || 0;\n        self.goToSlide(targetSlide);\n      } else {\n        // If slidesToShow didn't change, stay on current slide but reposition it.\n        self.goToSlide(self.currentSlide);\n      }\n    }, 100);\n  }\n\n  /**\n   * Enhanced destroy method to clean up infinite scroll timeouts\n   *\n   * @returns {void}\n   */\n  destroy() {\n    this.stopAutoplay();\n    clearTimeout(this.scrollTimeout);\n    clearTimeout(this.infiniteScrollTimeout);\n\n    // Clean up any cloned slides\n    if (this.track) {\n      const clones = this.track.querySelectorAll('.infinite-clone');\n      clones.forEach(clone => clone.remove());\n    }\n  }\n}\n\nexport default NativeScrollSlider;\n\n// Also make available globally when used in browser.\nif (typeof window !== 'undefined') {\n  window.NativeScrollSlider = NativeScrollSlider;\n}\n"],"names":["NativeScrollSlider","trackElement","options","element","passedOptions","defaults","dataConfig","e","selector","button","sliderControls","self","style","viewportWidth","containerMaxWidth","basePadding","leftPadding","width","currentOptions","sortedBreakpoints","a","b","i","breakpoint","containerWidth","totalGaps","slideWidth","overflowSlideWidth","totalNeededWidth","effectiveWidth","calculatedSlideWidth","minSlideWidth","minWidth","numericValue","mode","slidesToClone","originalIndex","clone","startIndex","initialPosition","trackStyles","trackPaddingLeft","trackPaddingRight","visibleTrackWidth","slidesPerView","clonesNeeded","slidesToUse","scrollLeft","adjustedScrollLeft","containerStyles","containerPaddingLeft","containerPaddingRight","containerInnerWidth","closestSlide","closestDistance","position","comparePosition","distance","cloneCount","targetIndex","totalOriginalWidth","leftBoundary","rightBoundary","equivalentPosition","slideIndex","targetPosition","newPosition","originalBehavior","gap","actualSlidesToShow","scrollAmount","nextCenterSlide","nextSlide","prevCenterSlide","prevSlide","centerPoint","slide","slideCenter","targetSlide","slideLeft","maxScroll","currentScroll","centerSlideIndex","previousSlidesToShow","previousShowOverflow"],"mappings":"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"}